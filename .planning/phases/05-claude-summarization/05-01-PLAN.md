---
phase: 05-claude-summarization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/summary.ts
  - api/summarize.ts
  - src/services/claude.service.ts
autonomous: true

must_haves:
  truths:
    - "Claude API calls are proxied through a Vercel Edge Function to avoid CORS and key exposure"
    - "Structured summary output matches the Zod schema (title, key_points, topics, notable_quotes)"
    - "Token counting returns accurate input token count for cost estimation"
  artifacts:
    - path: "src/types/summary.ts"
      provides: "Summary Zod schema, TypeScript types, SummaryResult, SummaryStatus"
      contains: "SummarySchema"
    - path: "api/summarize.ts"
      provides: "Vercel Edge Function proxy for Claude API"
      exports: ["handler"]
    - path: "src/services/claude.service.ts"
      provides: "Client-side Claude service (summarize, countTokens)"
      exports: ["summarizeTranscript", "countTranscriptTokens"]
  key_links:
    - from: "src/services/claude.service.ts"
      to: "api/summarize.ts"
      via: "fetch POST to /api/summarize"
      pattern: "fetch.*api/summarize"
    - from: "src/types/summary.ts"
      to: "src/services/claude.service.ts"
      via: "Zod schema import for response validation"
      pattern: "import.*SummarySchema"
---

<objective>
Create the foundation for Claude API integration: TypeScript types with Zod schemas for structured output, a Vercel Edge Function proxy for Claude API calls (same pattern as transcript proxy), and a client-side service for summarization and token counting.

Purpose: Establish the Claude API integration layer that all subsequent plans build upon. The proxy pattern mirrors Phase 4's transcript proxy, keeping API keys server-side and avoiding CORS issues.
Output: Working Claude API proxy, summary types, and client service with summarize + countTokens functions.
</objective>

<execution_context>
@/Users/nathanstasin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanstasin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-claude-summarization/05-RESEARCH.md

# Existing patterns to follow
@api/transcripts.ts
@src/services/transcript.service.ts
@src/types/transcript.ts
@src/context/ApiKeysContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create summary types and Zod schema</name>
  <files>src/types/summary.ts</files>
  <action>
Create `src/types/summary.ts` with:

1. **Zod schema** `SummarySchema` using the `zod` library:
   ```typescript
   import { z } from 'zod';

   export const SummarySchema = z.object({
     title: z.string(),
     key_points: z.array(z.string()).min(3).max(10),
     topics: z.array(z.string()).min(1).max(5),
     notable_quotes: z.array(z.object({
       text: z.string(),
       context: z.string().optional(),
     })).max(5),
   });
   ```

2. **Inferred TypeScript type** from Zod schema:
   ```typescript
   export type Summary = z.infer<typeof SummarySchema>;
   ```

3. **SummaryStatus type** (mirrors TranscriptStatus pattern):
   ```typescript
   export type SummaryStatus = 'queued' | 'estimating' | 'processing' | 'completed' | 'failed';
   ```

4. **SummaryResult interface** (mirrors TranscriptResult pattern):
   ```typescript
   export interface SummaryResult {
     videoId: string;
     status: SummaryStatus;
     summary?: Summary;
     error?: string;
     cost?: number;           // Actual API cost in USD
     inputTokens?: number;    // Tokens consumed
     outputTokens?: number;
   }
   ```

5. **CostEstimate interface**:
   ```typescript
   export interface CostEstimate {
     videoId: string;
     inputTokens: number;
     estimatedCost: number;   // USD
     needsChunking: boolean;  // True if > CHUNK_THRESHOLD tokens
   }

   export interface BatchCostEstimate {
     estimates: CostEstimate[];
     totalInputTokens: number;
     totalEstimatedCost: number;  // Includes 10% buffer
     videosNeedingChunking: number;
   }
   ```

6. **Constants**:
   ```typescript
   export const CLAUDE_MODEL = 'claude-sonnet-4-5-20250514';
   export const MAX_OUTPUT_TOKENS = 4096;
   export const INPUT_PRICE_PER_MTOK = 3;    // $3/MTok
   export const OUTPUT_PRICE_PER_MTOK = 15;   // $15/MTok
   export const COST_BUFFER_PERCENT = 0.10;   // 10% buffer
   export const CHUNK_TOKEN_THRESHOLD = 50000; // Chunk transcripts above this
   ```

Use `import type` where appropriate. Follow existing type file patterns from `src/types/transcript.ts`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors.</verify>
  <done>Summary types, Zod schema, status types, cost estimate interfaces, and pricing constants all defined and type-check cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create Claude API Edge Function proxy and client service</name>
  <files>api/summarize.ts, src/services/claude.service.ts</files>
  <action>
**Part A: Create `api/summarize.ts`** (Vercel Edge Function)

Follow the exact same pattern as `api/transcripts.ts`. This Edge Function proxies Claude API calls so the Anthropic API key stays server-side and avoids CORS.

The Edge Function accepts POST requests with JSON body:
```typescript
interface SummarizeRequest {
  transcript: string;
  apiKey: string;   // User's Anthropic key passed from client
  action: 'summarize' | 'count-tokens';
}
```

Implementation:
1. Export `config = { runtime: 'edge' }` and default handler
2. Add CORS headers (same pattern as transcripts.ts)
3. Handle OPTIONS preflight
4. Parse JSON body, validate required fields (transcript, apiKey, action)
5. For `action: 'summarize'`:
   - Import `Anthropic` from `@anthropic-ai/sdk`
   - Create client with user's apiKey and `dangerouslyAllowBrowser: false`
   - Call `client.messages.create()` with:
     - model: `claude-sonnet-4-5-20250514`
     - max_tokens: 4096
     - System prompt instructing structured JSON output (title, key_points as array of strings, topics as array of strings, notable_quotes as array of {text, context?})
     - User message with transcript
   - Return `{ success: true, summary: parsedJSON, usage: { input_tokens, output_tokens } }`
   - Check `response.stop_reason === 'max_tokens'` and return error if truncated
6. For `action: 'count-tokens'`:
   - Call `client.messages.countTokens()` with the same model and message structure
   - Return `{ success: true, inputTokens: result.input_tokens }`
7. Error handling:
   - 400 for missing fields
   - 401 for invalid API key (catch Anthropic auth errors)
   - 429 for rate limit (pass through Anthropic 429)
   - 500 for other errors
   - 60-second timeout using Promise.race (longer than transcript proxy since Claude processing takes time)

IMPORTANT: Do NOT use `zodOutputFormat` or structured outputs in the Edge Function. The Edge Function uses plain JSON mode via system prompt instructions. Zod validation happens client-side in claude.service.ts. This avoids importing the Zod library into the Edge Function bundle.

The system prompt should be:
```
You are a video transcript analyzer. Analyze the provided YouTube video transcript and return a JSON object with this exact structure:
{
  "title": "A concise, descriptive title for the video content",
  "key_points": ["3-10 key takeaways from the video"],
  "topics": ["1-5 main topics covered"],
  "notable_quotes": [{"text": "exact quote", "context": "brief context"}]
}
Return ONLY valid JSON, no markdown formatting or code blocks.
```

**Part B: Create `src/services/claude.service.ts`**

Client-side service that calls the Edge Function proxy. Follow patterns from `src/services/transcript.service.ts`.

```typescript
import { SummarySchema } from '@/types/summary';
import type { Summary } from '@/types/summary';
import { CLAUDE_MODEL, MAX_OUTPUT_TOKENS, INPUT_PRICE_PER_MTOK, OUTPUT_PRICE_PER_MTOK } from '@/types/summary';

const PROXY_BASE = '/api/summarize';

export interface SummarizeResult {
  summary: Summary;
  inputTokens: number;
  outputTokens: number;
  cost: number;
}

export async function summarizeTranscript(
  transcript: string,
  apiKey: string
): Promise<SummarizeResult>
```

Implementation:
1. `summarizeTranscript(transcript, apiKey)`:
   - POST to `/api/summarize` with `{ transcript, apiKey, action: 'summarize' }`
   - Parse response JSON
   - Validate with `SummarySchema.parse(data.summary)` (Zod validation client-side)
   - Calculate cost from usage: `(input_tokens / 1M) * 3 + (output_tokens / 1M) * 15`
   - Return `{ summary, inputTokens, outputTokens, cost }`
   - Throw descriptive errors for non-200 responses

2. `countTranscriptTokens(transcript, apiKey)`:
   - POST to `/api/summarize` with `{ transcript, apiKey, action: 'count-tokens' }`
   - Return `{ inputTokens: number }`

3. Add retry logic with exponential backoff for transient errors (429, 500+):
   - Max 3 retries, base delay 1000ms, exponential backoff
   - Only retry on 429 (rate limit), 408 (timeout), 5xx (server error)
   - Do NOT retry on 400, 401, 404

Also update `vite.config.ts` proxy configuration if needed to route `/api/summarize` to the Edge Function in dev mode (check if the existing proxy config for `/api/transcripts` already handles `/api/*` generically).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds (no import errors in Edge Function)
3. Verify `api/summarize.ts` handles POST with correct CORS headers by inspection
  </verify>
  <done>
Edge Function at `/api/summarize` accepts POST requests for both summarize and count-tokens actions. Client service validates responses with Zod, calculates costs, and includes retry logic for transient errors. Both files type-check and build successfully.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npm run build` — builds successfully
3. All three files exist: `src/types/summary.ts`, `api/summarize.ts`, `src/services/claude.service.ts`
4. `SummarySchema` is importable from types
5. Edge Function follows same pattern as `api/transcripts.ts` (CORS, runtime edge, error handling)
6. Claude service exports `summarizeTranscript` and `countTranscriptTokens`
</verification>

<success_criteria>
- Summary types and Zod schema defined and importable
- Edge Function proxy handles summarize and count-tokens actions
- Client service validates Claude responses with Zod
- Cost calculation uses correct pricing constants
- Retry logic handles transient errors (429, 5xx)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-claude-summarization/05-01-SUMMARY.md`
</output>
