---
phase: 02-channel-video-listing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/youtube/youtube-api.ts
  - src/lib/youtube/cache.ts
  - src/lib/youtube/quota.ts
autonomous: true

must_haves:
  truths:
    - "Channel URL resolves to uploads playlist ID via channels.list API (1 unit, not search.list at 100 units)"
    - "Videos are fetched from uploads playlist via playlistItems.list (1 unit per page)"
    - "API responses are cached in localStorage with TTL to prevent duplicate calls"
    - "Quota exhaustion (403) is detected and reset time is calculated"
  artifacts:
    - path: "src/lib/youtube/youtube-api.ts"
      provides: "YouTube Data API v3 service"
      exports: ["resolveChannel", "fetchVideosPage"]
    - path: "src/lib/youtube/cache.ts"
      provides: "localStorage cache with TTL"
      exports: ["getCached", "setCache", "clearCache"]
    - path: "src/lib/youtube/quota.ts"
      provides: "Quota tracking and error handling"
      exports: ["QuotaTracker", "isQuotaExhausted", "getQuotaResetTime"]
  key_links:
    - from: "src/lib/youtube/youtube-api.ts"
      to: "src/types/youtube.ts"
      via: "import type"
      pattern: "import type.*ChannelInfo|VideoItem|VideosPage"
    - from: "src/lib/youtube/youtube-api.ts"
      to: "src/lib/youtube/cache.ts"
      via: "cache reads before API calls"
      pattern: "getCached.*fetch"
    - from: "src/lib/youtube/youtube-api.ts"
      to: "src/lib/youtube/quota.ts"
      via: "quota error detection in catch blocks"
      pattern: "isQuotaExhausted|quotaExceeded"
---

<objective>
Build the YouTube Data API v3 service layer with aggressive client-side caching and quota management.

Purpose: This is the data backbone of Phase 2. The service must be quota-efficient (channels.list + playlistItems.list at 1 unit each, NEVER search.list at 100 units), cache responses to prevent wasted calls, and gracefully handle quota exhaustion with reset time calculation.

Output: Three modules -- API service, cache layer, quota tracker -- all typed against the youtube.ts types from Plan 01.
</objective>

<execution_context>
@/Users/nathanstasin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanstasin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-channel-video-listing/02-RESEARCH.md
@.planning/phases/02-channel-video-listing/02-01-SUMMARY.md
@src/types/youtube.ts
@src/lib/youtube/parse-channel-url.ts
@src/context/ApiKeysContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cache layer and quota tracker</name>
  <files>
    src/lib/youtube/cache.ts
    src/lib/youtube/quota.ts
  </files>
  <action>
    Create src/lib/youtube/cache.ts:
    - getCached<T>(key: string): T | null -- reads from localStorage, checks TTL, returns null if expired or missing
    - setCache<T>(key: string, data: T, ttlMs: number): void -- writes to localStorage with timestamp
    - clearCache(): void -- removes all yt_ prefixed keys from localStorage
    - Cache key format: `yt_${type}_${identifier}` (e.g., `yt_channel_MrBeast`, `yt_videos_UUxxx_page1`)
    - TTL constants: CHANNEL_CACHE_TTL = 24 * 60 * 60 * 1000 (24 hours), VIDEOS_CACHE_TTL = 60 * 60 * 1000 (1 hour)
    - Wrap localStorage calls in try/catch (storage full, private browsing)
    - Store as JSON: { data: T, timestamp: number, ttl: number }

    Create src/lib/youtube/quota.ts:
    - QuotaTracker class or object:
      - trackCall(units: number): void -- increments estimated quota usage in sessionStorage
      - getEstimatedUsage(): number -- returns current session's estimated quota usage
      - isQuotaExhausted(): boolean -- returns true if a 403 quotaExceeded was received this session
      - setQuotaExhausted(): void -- marks quota as exhausted
      - getQuotaResetTime(): Date -- returns next midnight PT (Pacific Time = UTC-8, or UTC-7 during DST)
        - Calculate: next occurrence of 00:00 America/Los_Angeles in UTC
        - Use: new Date() to get current time, calculate offset to next midnight PT
      - getEstimatedRemaining(): number -- rough estimate (10000 - estimated usage), best-effort
    - Storage key: `yt_quota_${date}` where date is YYYY-MM-DD in PT timezone
    - Reset tracking automatically when date changes (new PT day)

    IMPORTANT: Do NOT use date-fns. Use native Date/Intl APIs for the midnight PT calculation. The research suggested date-fns but it's not worth adding a dependency for one calculation.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Both files export their documented functions/classes
    - Cache handles localStorage errors gracefully (try/catch)
  </verify>
  <done>
    - Cache reads/writes/clears localStorage with TTL checking
    - Quota tracker calculates next midnight PT reset time
    - Quota tracker detects exhaustion state
    - Both modules are typed and error-resilient
  </done>
</task>

<task type="auto">
  <name>Task 2: YouTube Data API v3 service</name>
  <files>src/lib/youtube/youtube-api.ts</files>
  <action>
    Create src/lib/youtube/youtube-api.ts with two main functions:

    1. resolveChannel(identifier: ChannelIdentifier, apiKey: string): Promise<ChannelInfo>
       - Check cache first: getCached(`yt_channel_${identifier.type}_${identifier.value}`)
       - If cache miss, call YouTube Data API v3:
         - URL: https://www.googleapis.com/youtube/v3/channels
         - Parameters based on identifier.type:
           - "handle" -> ?forHandle={value}&part=snippet,contentDetails
           - "username" -> ?forUsername={value}&part=snippet,contentDetails
           - "channelId" -> ?id={value}&part=snippet,contentDetails
           - "customUrl" -> ?forHandle={value}&part=snippet,contentDetails (try handle first, custom URLs often resolve as handles)
         - Add &key={apiKey}
       - Parse response: extract items[0].id, items[0].snippet.title, items[0].snippet.thumbnails.default.url, items[0].contentDetails.relatedPlaylists.uploads
       - If items is empty, throw descriptive error: "Channel not found. Check the URL and try again."
       - Cache result with CHANNEL_CACHE_TTL
       - Track quota: quotaTracker.trackCall(1)
       - Return ChannelInfo object

    2. fetchVideosPage(uploadsPlaylistId: string, apiKey: string, pageToken?: string): Promise<VideosPage>
       - Check cache first: getCached(`yt_videos_${uploadsPlaylistId}_${pageToken || 'first'}`)
       - If cache miss, call YouTube Data API v3:
         - URL: https://www.googleapis.com/youtube/v3/playlistItems
         - Parameters: ?playlistId={uploadsPlaylistId}&part=snippet,contentDetails&maxResults=50&key={apiKey}
         - If pageToken: add &pageToken={pageToken}
       - Parse response: map items to VideoItem[] extracting:
         - id: contentDetails.videoId
         - title: snippet.title
         - thumbnail: snippet.thumbnails.medium.url (fallback to default)
         - publishedAt: snippet.publishedAt (ISO string, keep as-is for now)
         - duration: "" (playlistItems doesn't return duration -- leave empty, will be addressed if needed)
       - Extract nextPageToken (null if not present) and pageInfo.totalResults
       - Cache result with VIDEOS_CACHE_TTL
       - Track quota: quotaTracker.trackCall(1)
       - Return VideosPage object

    Error handling for BOTH functions:
    - Catch fetch errors
    - If response.status === 403: check error.errors[0].reason === "quotaExceeded"
      - If quota: call quotaTracker.setQuotaExhausted(), throw YouTubeApiError with isQuotaExhausted: true, quotaResetTime from tracker
    - If response.status === 400: throw with "Invalid request" message
    - If response.status === 404: throw with "Not found" message
    - Parse error body as JSON for YouTube error message: error.message

    Use native fetch (no axios). Use `import type` for TypeScript types.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports resolveChannel and fetchVideosPage
    - Both functions check cache before making API calls
    - Both functions track quota after API calls
    - 403 quotaExceeded is caught and sets quota exhausted state
  </verify>
  <done>
    - resolveChannel converts any ChannelIdentifier to ChannelInfo via YouTube API
    - fetchVideosPage retrieves 50 videos per page with pagination token support
    - All API calls are cached with TTL
    - Quota exhaustion is detected and tracked with reset time
    - Zero TypeScript errors
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- All three files exist and export their documented APIs
- Cache layer handles localStorage failures gracefully
- Quota tracker calculates correct PT midnight reset
- API service checks cache before every network call
- API service handles 403 quota errors specifically
</verification>

<success_criteria>
- resolveChannel works for all 4 identifier types (handle, channelId, username, customUrl)
- fetchVideosPage supports cursor-based pagination with pageToken
- Responses cached in localStorage with correct TTLs (24h channels, 1h videos)
- Quota exhaustion detected and reset time calculated
- All functions typed against src/types/youtube.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-channel-video-listing/02-02-SUMMARY.md`
</output>
