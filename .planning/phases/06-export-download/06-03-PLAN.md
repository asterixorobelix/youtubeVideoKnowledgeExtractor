---
phase: 06-export-download
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useSummarization.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Export/Download button appears after summarization completes"
    - "Button shows accurate count of completed summaries"
    - "Summarize button disappears when processing starts"
  artifacts:
    - path: "src/hooks/useSummarization.ts"
      provides: "Summarization state with race-condition-free completion detection"
      min_lines: 200
  key_links:
    - from: "src/hooks/useSummarization.ts"
      to: "src/App.tsx"
      via: "summaryPhase and completedCount values"
      pattern: "summaryPhase === 'complete' && completedCount > 0"
---

<objective>
Fix race condition preventing Export button from appearing after summarization completes

**Purpose:** Resolve blocker UAT gap where Promise.all completion dispatches COMPLETE before all SET_VIDEO_RESULT actions are batched by React, causing completedCount=0 when phase transitions to 'complete'. This prevents the ExportButton from becoming visible (condition: summaryPhase==='complete' && completedCount > 0).

**Output:** Working export button visibility after summarization completes with at least one successful summary.
</objective>

<execution_context>
@/Users/nathanstasin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanstasin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-export-download/06-01-SUMMARY.md
@.planning/phases/06-export-download/06-02-SUMMARY.md
@.planning/phases/06-export-download/06-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Fix race condition in summarization completion detection</name>
  <files>src/hooks/useSummarization.ts</files>
  <action>
**Root cause:** In `startProcessing` function (lines 174-211), `Promise.all` completes and dispatches `COMPLETE` action before React batches all `SET_VIDEO_RESULT` actions. When reducer processes COMPLETE, it sets `phase: 'complete'` but `completedCount` (derived from `state.results`) is still 0 because state updates are batched.

**Fix approach:** Derive phase='complete' from state instead of explicit dispatch.

**Changes to make:**

1. **Remove COMPLETE action dispatch** (line 210)
   - Delete: `dispatch({ type: 'COMPLETE' })`
   - Reason: Completion should be derived from processedCount, not explicitly set

2. **Update reducer to derive phase from processedCount**
   - In `SET_VIDEO_RESULT` and `SET_VIDEO_ERROR` cases (lines 91-107 and 109-125)
   - After incrementing `processedCount`, check if processing is complete
   - Add logic: `const isComplete = state.processedCount + 1 >= state.results.size`
   - If true, set `phase: 'complete'`, otherwise keep `phase: 'processing'`

3. **Remove COMPLETE case from reducer** (lines 127-131)
   - No longer needed since completion is derived

4. **Add total count to state** (better alternative)
   - Add `totalCount: number` field to SummarizationState
   - Set in START_PROCESSING: `totalCount: action.videoIds.length`
   - Derive completion: `processedCount >= totalCount`
   - This is cleaner than using `results.size`

**Why this fixes the race:** Phase='complete' now transitions in the SAME action that updates results, so completedCount and phase are always in sync.

**Implementation:**

```typescript
// Add to SummarizationState interface
interface SummarizationState {
  phase: 'idle' | 'estimating' | 'estimated' | 'processing' | 'complete'
  results: Map<string, SummaryResult>
  costEstimate: BatchCostEstimate | null
  totalActualCost: number
  processedCount: number
  totalCount: number  // ADD THIS
}

// Update initialState
const initialState: SummarizationState = {
  phase: 'idle',
  results: new Map(),
  costEstimate: null,
  totalActualCost: 0,
  processedCount: 0,
  totalCount: 0,  // ADD THIS
}

// Update START_PROCESSING case
case 'START_PROCESSING': {
  const newResults = new Map<string, SummaryResult>()
  action.videoIds.forEach((videoId) => {
    newResults.set(videoId, {
      videoId,
      status: 'queued',
    })
  })
  return {
    ...state,
    phase: 'processing',
    results: newResults,
    totalActualCost: 0,
    processedCount: 0,
    totalCount: action.videoIds.length,  // ADD THIS
  }
}

// Update SET_VIDEO_RESULT case
case 'SET_VIDEO_RESULT': {
  const newResults = new Map(state.results)
  newResults.set(action.videoId, {
    videoId: action.videoId,
    status: 'completed',
    summary: action.summary,
    cost: action.cost,
    inputTokens: action.inputTokens,
    outputTokens: action.outputTokens,
  })
  const newProcessedCount = state.processedCount + 1
  const isComplete = newProcessedCount >= state.totalCount  // ADD THIS
  return {
    ...state,
    results: newResults,
    totalActualCost: state.totalActualCost + action.cost,
    processedCount: newProcessedCount,
    phase: isComplete ? 'complete' : 'processing',  // CHANGE THIS
  }
}

// Update SET_VIDEO_ERROR case similarly
case 'SET_VIDEO_ERROR': {
  const newResults = new Map(state.results)
  const existing = newResults.get(action.videoId)
  newResults.set(action.videoId, {
    videoId: action.videoId,
    status: 'failed',
    error: action.error,
    cost: existing?.cost,
    inputTokens: existing?.inputTokens,
    outputTokens: existing?.outputTokens,
  })
  const newProcessedCount = state.processedCount + 1
  const isComplete = newProcessedCount >= state.totalCount  // ADD THIS
  return {
    ...state,
    results: newResults,
    processedCount: newProcessedCount,
    phase: isComplete ? 'complete' : 'processing',  // CHANGE THIS
  }
}

// Remove COMPLETE case entirely
// DELETE lines 127-131

// Remove COMPLETE from SummarizationAction type
type SummarizationAction =
  | { type: 'START_ESTIMATE' }
  | { type: 'SET_ESTIMATE'; estimate: BatchCostEstimate }
  | { type: 'ESTIMATE_ERROR'; error: string }
  | { type: 'START_PROCESSING'; videoIds: string[] }
  | { type: 'SET_VIDEO_STATUS'; videoId: string; status: SummaryStatus }
  | { type: 'SET_VIDEO_RESULT'; videoId: string; summary: any; cost: number; inputTokens: number; outputTokens: number }
  | { type: 'SET_VIDEO_ERROR'; videoId: string; error: string }
  // DELETE: | { type: 'COMPLETE' }
  | { type: 'RESET' }

// Remove dispatch({ type: 'COMPLETE' }) from startProcessing
// DELETE line 210
```

**Verification:** After changes, the phase will transition to 'complete' in the same render cycle as the last video result is added, ensuring completedCount > 0 when phase='complete'.
  </action>
  <verify>
1. Run build: `npm run build` should succeed with no type errors
2. Run tests: `npm test` should pass (no tests need updating)
3. Manual test: Start dev server, complete full flow (channel -> select -> extract -> summarize)
4. Observe: After summarization completes, Export button appears immediately with correct count
  </verify>
  <done>
- Export/Download button appears after summarization with at least one completed summary
- No race condition between phase transition and completedCount calculation
- completedCount > 0 when phase='complete' (guaranteed by derived state logic)
  </done>
</task>

</tasks>

<verification>
1. TypeScript build passes
2. All tests pass (no test changes needed)
3. Manual UAT test #1 passes: Export button appears after summarization completes
4. No console errors during summarization or export
</verification>

<success_criteria>
- Phase='complete' transition happens in same action as final result update
- completedCount and phase are always in sync (no race condition possible)
- Export button becomes visible immediately after last video processes
- UAT Test #1 status changes from "issue" to "pass"
</success_criteria>

<output>
After completion, create `.planning/phases/06-export-download/06-03-SUMMARY.md`
</output>
