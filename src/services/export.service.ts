import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { VideoItem } from '@/types/youtube';
import type { Summary } from '@/types/summary';

const WINDOWS_RESERVED_NAMES = new Set([
  'CON', 'PRN', 'AUX', 'NUL',
  'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
  'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9',
]);

const FORBIDDEN_CHARS_REGEX = /[<>:"/\\|?*\x00-\x1F]/g;
const MAX_FILENAME_LENGTH = 80;

/**
 * Sanitizes a filename to be cross-platform safe
 * - Removes Windows forbidden characters
 * - Removes leading dots and control characters
 * - Removes trailing spaces and dots
 * - Replaces whitespace with underscores
 * - Handles Windows reserved names
 * - Truncates to 80 characters
 */
export function sanitizeFilename(input: string): string {
  // Remove forbidden characters and control characters
  let sanitized = input.replace(FORBIDDEN_CHARS_REGEX, '');

  // Remove leading dots (hidden files on Unix)
  sanitized = sanitized.replace(/^\.+/, '');

  // Remove trailing spaces and dots
  sanitized = sanitized.replace(/[\s.]+$/, '');

  // Replace remaining whitespace with underscores
  sanitized = sanitized.replace(/\s+/g, '_');

  // Return 'untitled' if empty after sanitization
  if (sanitized.length === 0) {
    return 'untitled';
  }

  // Truncate to max length
  if (sanitized.length > MAX_FILENAME_LENGTH) {
    sanitized = sanitized.substring(0, MAX_FILENAME_LENGTH);
  }

  // Check for Windows reserved names (case-insensitive)
  const upperSanitized = sanitized.toUpperCase();
  if (WINDOWS_RESERVED_NAMES.has(upperSanitized)) {
    sanitized = '_' + sanitized;
  }

  return sanitized;
}

/**
 * Generates a collision-safe markdown filename.
 *
 * Naming convention:
 *   {channel_name}-{video_id}_{sanitized_title}.md
 *
 * Examples:
 *   Matthew_Berman-fmNzXCp7zA_Clawdbot_just_got_scary_(Moltbook).md
 *   3Blue1Brown-abc123_But_what_is_a_neural_network.md
 *
 * Falls back to {video_id}_{sanitized_title}.md when channel name is unavailable.
 * The video ID guarantees uniqueness even if titles collide.
 */
export function generateFilename(video: VideoItem, channelName?: string): string {
  const sanitizedTitle = sanitizeFilename(video.title);
  if (channelName) {
    const sanitizedChannel = sanitizeFilename(channelName);
    return `${sanitizedChannel}-${video.id}_${sanitizedTitle}.md`;
  }
  return `${video.id}_${sanitizedTitle}.md`;
}

/**
 * Formats a date string to human-readable format
 */
function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

/**
 * Generates markdown content from video and summary data
 */
export function generateMarkdown(video: VideoItem, summary: Summary): string {
  const sections: string[] = [];

  // Title
  sections.push(`# ${summary.title}\n`);

  // Video metadata
  sections.push(`**Video:** [${video.title}](https://youtube.com/watch?v=${video.id})`);
  sections.push(`**Published:** ${formatDate(video.publishedAt)}`);
  sections.push(`**Duration:** ${video.duration}\n`);

  // Key Points
  sections.push('## Key Points\n');
  summary.key_points.forEach((point, index) => {
    sections.push(`${index + 1}. ${point}`);
  });
  sections.push('');

  // Topics
  sections.push('## Topics Covered\n');
  summary.topics.forEach((topic) => {
    sections.push(`- ${topic}`);
  });
  sections.push('');

  // Notable Quotes
  if (summary.notable_quotes.length > 0) {
    sections.push('## Notable Quotes\n');
    summary.notable_quotes.forEach((quote) => {
      sections.push(`> ${quote.text}`);
      if (quote.context) {
        sections.push(`> *Context: ${quote.context}*`);
      }
      sections.push('');
    });
  }

  // Footer
  sections.push('---\n');
  sections.push('*Generated by YouTube Knowledge Extractor*');

  return sections.join('\n');
}

/**
 * Exports summaries to a zip file and triggers browser download
 */
export async function exportSummariesToZip(
  summaries: Array<{ video: VideoItem; summary: Summary }>,
  channelName?: string
): Promise<void> {
  const zip = new JSZip();
  const usedFilenames = new Set<string>();

  // Add markdown files to zip
  summaries.forEach(({ video, summary }) => {
    let filename = generateFilename(video, channelName);

    // Handle filename collisions (paranoid safety)
    let counter = 1;
    while (usedFilenames.has(filename)) {
      const sanitizedTitle = sanitizeFilename(video.title);
      filename = `${video.id}_${sanitizedTitle}_${counter}.md`;
      counter++;
    }
    usedFilenames.add(filename);

    const markdown = generateMarkdown(video, summary);
    zip.file(filename, markdown);
  });

  // Generate zip blob
  const blob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });

  // Zip naming convention:
  //   {channel_name}-summaries-{YYYY-MM-DD}.zip
  //   e.g. Matthew_Berman-summaries-2026-01-31.zip
  // Falls back to youtube-summaries-{YYYY-MM-DD}.zip without channel name.
  const today = new Date().toISOString().split('T')[0];
  const zipFilename = channelName
    ? `${sanitizeFilename(channelName)}-summaries-${today}.zip`
    : `youtube-summaries-${today}.zip`;
  saveAs(blob, zipFilename);
}
